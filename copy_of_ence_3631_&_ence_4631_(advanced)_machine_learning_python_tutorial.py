# -*- coding: utf-8 -*-
"""Copy of  ENCE 3631 & ENCE 4631 (Advanced) Machine Learning -- Python Tutorial.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cjW5OaNNAwp6syX60z6ZbsmItBUGlleB

# Python Tutorial

This lecture introduces the basic Python skills that help code homework assignment easily.

Content \\
1 Basic Logic \\
2 DataType \\
3 Basic Operator \\
4 Common Statement \\
5 Define Function \\
6 Define Class \\
7 Common Packages \\
8 Code Used in This Lecture \\

# 1 Basic Logic

1.   inserting pound key # means we are going to comment the code or words after it.
2.   = means assignment. We use this symbol to assign the right value to the left variable.
3. print is the very common command in programming language. It prints out anything within the quotation mark in the parenthesis.
"""

# inserting pound key means we are going to comment the code or words after it. 
x = 1 # = means assignment. We use this symbol to assign the right value to the left variable.
y = x + 3 
print("There are two variables x and y.") # Here are two different print methods
print(f'x={x}, y={y}')

"""# 2 DataType

* Text Type: str
        anything under quotation mark is defined as string.
* Numeric Types: int, float, complex
        any length of numeric value + decimal point + any length of numeric value.
        complex means plural.
* Sequence Types: list, tuple, range
        list: [element 1,element 2,...,element n]
        tuple: (element 1, element 2). Usually, each tuple has two elements. In python, you can make it more at will.
        range: from 0 to the inserted integer value n - 1
* Mapping Type: dict
        dictionary has one or more key-value pair. The format is key:value. 
        key: we call this as key-value. Typically, it is string, but it can also be other datatype.
        value: we call this as value-value. It can be any datatype.
Set Types: set
        set: {element 1,element 2,...,element n}.
        Different from list, set ignores duplicate values and accepts elements with different datatype.
* Boolean Type: bool
        True (1) / False (0)
* Binary Types: bytes
        save binary sequence
* None Type: NoneType
        NoneType means this value doesn't exist
        Null means this value is not defined yet.
        They are different.

To check the exact datatype, we use type() function.
"""

# string
x1 = "[1, 2, 3, 4]"
y1 = "not only in a certain format"
print(f'string can be x:{x1}, {y1} like y.')
print("x1 type:", type(x1),". y1 type:", type(y1),".")
# number
x2 = 3.1415926
x3 = round(x2) # round() function helps shake off decimal part
print("x2 is",x2," with the datatype of",type(x2),"; x3 is",x3," with the datatype of",type(x3),".")
# sequence
x4 = eval(x1) # eval() function helps to convert the string list into list.
print("x4 is",x4,". x4 type is",type(x4))
x5 = ("a","b","c")
print("x5 is",x5,". x5 type is",type(x5))
x6 = range(len(x4)) # len() returns the length of the list
print("x6 is",x6,". x6 type is",type(x6))
# dictionary
x7 = {"key1":2023,"key2":"Monday","key3":["score1","score2"]}
print("x7 is",x7,". x7 type is",type(x7))
# bool
x8 = True
print("x8 is",not x8,". x8 type is",type(x8)) # not helps change the True value into False one.

"""# 3 Basic Operator

Arithmetic operators, +, -, \*, /, %, \*\*, // \\
Assignment operators, +=, -=, *=, /=, %=, **=, //=, &=, |= \\
Comparison operators, ==, !=, >, <, >=, <= \\
Logical operators, and, or, not \\
Identity operators, is, is not \\
Membership operators, in, not in \\
Bitwise operators, &,|,~ \\
"""

x3 += x2

# Arithmetic operators and Assignment operators
print("original x3 is",x3)
x3 += 2 # x3 = x3 + 2
print("updated x3 is",x3)
x3 *= 2 # x3 = x3 * 2
print("updated x3 is",x3)
x9 = x3**2 
print("x9 is",x9)
print("x9>x3",x9>x3)

"""# 4 Common Statement
   
1. if-else 
        if criteria_1: 
            code_here 
        elif criteria_2: 
            code_here 
        else:
            code_here
2. while loops
        while criteria_3:
            code_here
        
3. for loops
       for i in sequence_variable:
           code_here
"""

for i in range(1,6, 2):
    print(i)

import random # this is the way to import packages. packages can help you code faster and easier
# if-else statement
x10 = random.randint(0,6)
y10 = random.randint(0,6)
if y10>x10:
    print("y10 is bigger.")
elif y10<x10:
    print("x10 is bigger.")
else:
    print("x10 equals to y10.")

# while loops
i=0
x11=["Mon","Tue","Wed","Thur","Fri","Sat","Sun"]
print("Which day do you like?")
while i<len(x11):
    print(x11[i]+"?")
    i+=1

# for loops
x12="FriesChickenWingBeefRibeyeKababMeatStewBBQDrumsGrilledBeefSteakTunaShrimp"
cnt=0
for i in x12:
    if i == "a":
        cnt+=1
print(f"Totally, there are {cnt} a.")

"""# 5 Define Function

        def func_name(para 1,...,para n):
            code here
"""

# function
import random
def test_num(n):
    even_cnt = 0
    for i in range(len(n)):
        if int(n[i])%2==1:
            print(f'{n[i]} is odd number.')
        else:
            print(f'{n[i]} is even number.')
            even_cnt += 1
    return even_cnt

x13 = str(random.randint(2532453464611414534,6236587946234123412342314453245235242))
even_cnt_another_name = test_num(x13)
print(even_cnt_another_name)

"""# 6 Define Class

        class cls_name(Parent class): # Parent Class is optional 
            def __init__(self, para1, para2, para3):
                super().__init__() # super() is optional
                self.para1 = para1
                self.para2 = para2
                self.para3 = para3
            def func1(self, para4,para5):
                #code here
                x14 = self.para1+self.para4
                print(x14)
                return x14
            ...
            def func n(self, para4,para5):
                # code here
                output=self.func1(para4, para5) # this is how we call function within class
                return output

super() function makes the child class inherit all the methods and properties from its parent.

By using the super() function, you do not have to use the name of the parent element, it will automatically inherit the methods and properties from its parent.

## apply class
        x15 = cls_name(para1, para2, para3) # if __init__() don't take any parameters, we can use cls_name() directly.
        y15 = x15.func1(para4,para5) # this is how we apply function outside class
"""

class student_manage():
    def __init__(self, Year, Student_Number):
        self.year = Year
        self.student_number = Student_Number
        self.aver_GPA = 0
        self.roster = {}
        self.roster[1] = []
        self.roster[2] = []
        self.cnt = 0
    def add_one(self, name, gender, GPA, group_id):
        if self.cnt > self.student_number:
            return "Stop"
        else:
            self.cnt += 1
            self.roster[group_id].append([name, gender, GPA]) 
            print(f'{name} is added.')
            return "add one"
    def generate(self):
        return self.roster

student_info = student_manage(2023, 100)   
x16 = student_info.add_one("Tom Ford", "Male", 4.0, 1)
print(x16)
x17 = student_info.generate()
print(x17)

"""# 7 Common Packages

* System Management Packages 
        os, shutil, sys

* Scientific Operation Packages
        einops, math, matplotlib, numpy, pandas, 
        Pillow, random, scipy, sklearn, time
"""

!pip install einops
import os, shutil, sys
import einops, math, matplotlib, numpy, pandas
import PIL, random, scipy, sklearn, time

"""# 8 Assemble All Together"""

class student_manage():
    def __init__(self, Year, Student_Number):
        self.year = Year
        self.student_number = Student_Number
        self.aver_GPA = 0
        self.roster = {}
        self.roster["1"] = []
        self.roster["2"] = []
        self.cnt = 0
    def add_one(self, name, gender, GPA, group_id):
        if self.cnt > self.student_number:
            return "Stop"
        else:
            self.cnt += 1
            self.roster[str(group_id)].append([name, gender, GPA]) 
            print(f'{name} is added.')
            return "add one"
    def get_aver_GPA(self):
        all_GPA = 0
        self.grp_GPA_lst = []
        for k,v in self.roster.items():
            print("Working on group %d now." %(int(k)))
            grp_GPA = 0
            grp_len = len(v)
            for each_st in v:
                grp_GPA += each_st[2]
            grp_aver_GPA = grp_GPA/grp_len
            self.grp_GPA_lst.append(grp_aver_GPA)
            print("The average GPA of group %.2f is " %(grp_aver_GPA))
            all_GPA += grp_aver_GPA
        print("The average GPA for two groups is:","{:2f}".format(all_GPA/2))
        return self.grp_GPA_lst
    def group_compare(self):
        GPA_lst = self.get_aver_GPA()
        if GPA_lst[0]>GPA_lst[1]:
            print("Group 1 has higher average GPA.")
        else:
            print("Group 2 has higher average GPA.")
    def generate(self):
        return self.roster

import random
name_lst = ["Student_1","Student_2","Student_3","Student_4","Student_5","Student_6","Student_7","Student_8","Student_9","Student_10","Student_11","Student_12","Student_13","Student_14","Student_15","Student_16","Student_17","Student_18","Student_19","Student_20"]
gender_lst = ["Male", "Female","Male", "Female","Male", "Female","Male", "Female","Male", "Female","Male", "Female","Male", "Female","Male", "Female","Male", "Female","Male", "Female"]
GPA_lst = [round(random.uniform(0, 4), 2) for _ in range(20)]
id_lst = [random.randint(1,2) for _ in range(20)]
print(GPA_lst)
print(id_lst)

student_info = student_manage(2023, 15)   

for j in range(20):
    x18=student_info.add_one(name_lst[j],gender_lst[j],GPA_lst[j],id_lst[j])
    if x18 == "Stop":
        x18 = 20

x19 = student_info.generate()
print(x19)
student_info.group_compare()

"""# 9 Hidden Chapter

A More Practical but Wrong Example
"""

# add noise to images 
def add_noisy(image):
    ch,row,col = np.shape(image)
    mean = 0
    var = 0.01
    sigma = var**0.5
    gauss = np.random.normal(mean,sigma,(ch,row,col)) 
    gauss = np.reshape(gauss,(ch,row,col))
    noisy = image + gauss
    return noisy

num_test = len(y_test)
num_correct = np.sum(y_pred == y_test)
print('Got %d / %d correct' % (num_correct, num_test)) 
print('Accuracy = %f' % (np.mean(y_test == y_pred)))

